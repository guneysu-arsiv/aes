; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\hub\aes\aes2.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_aes_enc
PUBLIC	_aes_setkey
PUBLIC	_XT
PUBLIC	_gf_mulinv
PUBLIC	_SubByte
PUBLIC	_SubWord
; Function compile flags: /Ogspy
; File c:\hub\aes\aes2.c
;	COMDAT _SubWord
_TEXT	SEGMENT
_r$ = 8							; size = 4
_x$ = 8							; size = 4
_SubWord PROC						; COMDAT

; 72   : {

	push	ebp
	mov	ebp, esp

; 73   :     uint8_t i;
; 74   :     w32_t   r;
; 75   : 
; 76   :     r.w=x;

	mov	eax, DWORD PTR _x$[ebp]
	push	esi
	push	edi
	push	4
	mov	DWORD PTR _r$[ebp], eax
	lea	esi, DWORD PTR _r$[ebp]
	pop	edi
$LL4@SubWord:

; 77   :     
; 78   :     for (i=0; i<4; i++) {
; 79   :       r.b[i] = SubByte(r.b[i]);

	movzx	eax, BYTE PTR [esi]
	push	eax
	call	_SubByte
	mov	BYTE PTR [esi], al
	inc	esi
	pop	ecx
	sub	edi, 1
	jne	SHORT $LL4@SubWord

; 80   :     }
; 81   :     return r.w;

	mov	eax, DWORD PTR _r$[ebp]
	pop	edi
	pop	esi

; 82   : }

	pop	ebp
	ret	0
_SubWord ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\aes\aes2.c
;	COMDAT _SubByte
_TEXT	SEGMENT
_x$ = 8							; size = 1
_SubByte PROC						; COMDAT

; 57   :     uint8_t i, y=0, sb;
; 58   : 
; 59   :     sb = y = gf_mulinv (x);

	push	DWORD PTR _x$[esp-4]
	call	_gf_mulinv
	pop	ecx
	push	4
	mov	cl, al
	pop	edx
$LL4@SubByte:

; 60   : 
; 61   :     for (i=0; i<4; i++) {
; 62   :       y   = ROTL8(y, 1);

	rol	cl, 1

; 63   :       sb ^= y;

	xor	al, cl
	sub	edx, 1
	jne	SHORT $LL4@SubByte

; 64   :     }
; 65   :     return sb ^ 0x63;

	xor	al, 99					; 00000063H

; 66   : }

	ret	0
_SubByte ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\aes\aes2.c
;	COMDAT _gf_mulinv
_TEXT	SEGMENT
tv165 = 8						; size = 4
_x$ = 8							; size = 1
_gf_mulinv PROC						; COMDAT

; 33   : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 34   :     uint8_t y=x, i;

	mov	bl, BYTE PTR _x$[ebp]

; 35   : 
; 36   :     if (x)

	test	bl, bl
	je	SHORT $LN6@gf_mulinv

; 37   :     {
; 38   :       // calculate logarithm gen 3
; 39   :       for (y=1, i=0; ;i++) {
; 40   :         y ^= XT(y);

	push	1
	xor	bh, bh
	call	_XT
	pop	ecx
	mov	ecx, eax
	xor	cl, 1
	jmp	SHORT $LN20@gf_mulinv
$LL4@gf_mulinv:
	movzx	eax, cl
	inc	bh
	push	eax
	call	_XT
	pop	ecx
	mov	ecx, DWORD PTR tv165[ebp]
	xor	cl, al
$LN20@gf_mulinv:
	mov	DWORD PTR tv165[ebp], ecx

; 41   :         if (y==x) break;

	cmp	cl, bl
	jne	SHORT $LL4@gf_mulinv

; 44   :       // calculate anti-logarithm gen 3
; 45   :       for (y=1; i; i++) {

	mov	bl, 1
	add	bh, 2
	je	SHORT $LN6@gf_mulinv

; 42   :       }
; 43   :       i += 2;

	neg	bh
	push	esi
	movzx	esi, bh
$LL7@gf_mulinv:

; 46   :         y ^= XT(y);

	movzx	ecx, bl
	push	ecx
	call	_XT
	xor	bl, al
	pop	ecx
	sub	esi, 1
	jne	SHORT $LL7@gf_mulinv
	pop	esi
$LN6@gf_mulinv:

; 47   :       }
; 48   :     }
; 49   :     return y;

	mov	al, bl
	pop	ebx

; 50   : }

	pop	ebp
	ret	0
_gf_mulinv ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\aes\aes2.c
;	COMDAT _XT
_TEXT	SEGMENT
_w$ = 8							; size = 4
_XT	PROC						; COMDAT

; 24   :     uint32_t t = w & 0x80808080;

	mov	ecx, DWORD PTR _w$[esp-4]
	and	ecx, -2139062144			; 80808080H

; 25   :     
; 26   :     return ( (w ^ t ) << 1) ^ ( ( t >> 7) * 0x0000001B);

	mov	eax, ecx
	shr	ecx, 7
	xor	eax, DWORD PTR _w$[esp-4]
	imul	ecx, ecx, 27
	add	eax, eax
	xor	eax, ecx

; 27   : }

	ret	0
_XT	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\aes\aes2.c
;	COMDAT _aes_setkey
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_key$ = 12						; size = 4
_aes_setkey PROC					; COMDAT

; 89   :     int      i;
; 90   :     uint32_t x;
; 91   :     uint32_t *w=(uint32_t*)ctx->w;
; 92   :     uint32_t rcon=1;
; 93   : 
; 94   :     memcpy (w, key, Nk);

	mov	ecx, DWORD PTR _key$[esp-4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _ctx$[esp+8]
	xor	ebp, ebp
	mov	eax, DWORD PTR [ecx]
	inc	ebp
	push	edi

; 95   : 
; 96   :     for (i=Nk; i<Nb*(Nr+1); i++)

	push	8
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
	pop	ebx
$LL4@aes_setkey:

; 97   :     {
; 98   :       x = w[i-1];

	mov	edi, DWORD PTR [esi+28]

; 99   :       if ((i % Nk)==0) {

	mov	eax, ebx
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN13@aes_setkey
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN13@aes_setkey:
	jne	SHORT $LN5@aes_setkey

; 100  :         x = RotWord(x);

	ror	edi, 8

; 101  :         x = SubWord(x) ^ rcon;

	push	edi
	call	_SubWord
	mov	edi, eax

; 102  :         rcon=XT(rcon);

	push	ebp
	xor	edi, ebp
	call	_XT
	pop	ecx
	mov	ebp, eax
	jmp	SHORT $LN14@aes_setkey
$LN5@aes_setkey:

; 103  :       } else if ((Nk > 6) && ((i % Nk) == 4)) {

	cmp	eax, 4
	jne	SHORT $LN7@aes_setkey

; 104  :         x=SubWord(x);

	push	edi
	call	_SubWord
	mov	edi, eax
$LN14@aes_setkey:
	pop	ecx
$LN7@aes_setkey:

; 105  :       }
; 106  :       w[i] = w[i-Nk] ^ x;

	mov	ecx, DWORD PTR [esi]
	xor	ecx, edi
	inc	ebx
	mov	DWORD PTR [esi+32], ecx
	add	esi, 4
	cmp	ebx, 60					; 0000003cH
	jl	SHORT $LL4@aes_setkey

; 107  :     }
; 108  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
_aes_setkey ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\aes\aes2.c
;	COMDAT _aes_enc
_TEXT	SEGMENT
_v$ = -16						; size = 16
_state$ = 8						; size = 4
_key$ = 12						; size = 4
_aes_enc PROC						; COMDAT

; 110  : void aes_enc (void *state, void *key) {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp

; 111  :     w128_t  *s, *k, v;
; 112  :     uint32_t i, w, r;
; 113  :     
; 114  :     s=(w128_t*)state;
; 115  :     k=(w128_t*)key;
; 116  : 
; 117  :     // copy first key to local buffer
; 118  :     memcpy (&v, s, 16);

	mov	ebp, DWORD PTR _state$[esp+20]

; 119  :     r = 0;

	xor	ebx, ebx
	push	esi
	push	edi
	mov	esi, ebp
	lea	edi, DWORD PTR _v$[esp+32]
	movsd
	movsd
	movsd
	movsd
$add_key$35:

; 134  :                    ROTR32(w, 16) ^ 
; 135  :                    ROTL32(w,  8) ^ 
; 136  :                    XT(ROTR32(w, 8) ^ w);
; 137  :         }
; 138  :       }
; 139  : add_key:    
; 140  :       // add round key
; 141  :       for (i=0; i<4; i++) {

	mov	edx, DWORD PTR _key$[esp+28]
	xor	ecx, ecx
$LL13@aes_enc:

; 142  :         s->w[i] = v.w[i] ^ k->w[i];

	mov	eax, DWORD PTR [edx+ecx*4]
	xor	eax, DWORD PTR _v$[esp+ecx*4+32]
	mov	DWORD PTR [ebp+ecx*4], eax
	inc	ecx
	cmp	ecx, 4
	jb	SHORT $LL13@aes_enc

; 143  :       }
; 144  :       k++;    

	add	edx, 16					; 00000010H

; 145  :     } while (++r <= Nr);

	inc	ebx
	mov	DWORD PTR _key$[esp+28], edx
	cmp	ebx, 14					; 0000000eH
	ja	SHORT $LN22@aes_enc

; 120  :     goto add_key;
; 121  :     
; 122  :     do { 
; 123  :       // sub bytes and shift rows
; 124  :       for (i=0; i<16; i++) {     

	xor	edi, edi
$LL7@aes_enc:

; 125  :         v.m[((i >> 2) + 4 - (i & 3) ) & 3][i & 3] = SubByte(s->b[i]);

	movzx	eax, BYTE PTR [edi+ebp]
	mov	esi, edi
	push	eax
	and	esi, 3
	call	_SubByte
	pop	ecx
	mov	ecx, edi
	shr	ecx, 2
	sub	ecx, esi
	and	ecx, 3
	inc	edi
	lea	ecx, DWORD PTR [esi+ecx*4]
	mov	BYTE PTR _v$[esp+ecx+32], al
	cmp	edi, 16					; 00000010H
	jb	SHORT $LL7@aes_enc

; 126  :       }
; 127  :     
; 128  :       // if not last round
; 129  :       if (r != Nr) {

	cmp	ebx, 14					; 0000000eH
	je	SHORT $add_key$35

; 130  :         // mix columns
; 131  :         for (i=0; i<4; i++) {

	xor	ebp, ebp
$LL10@aes_enc:

; 132  :           w = v.w[i];

	mov	esi, DWORD PTR _v$[esp+ebp*4+32]

; 133  :           v.w[i] = ROTR32(w,  8) ^ 

	mov	edi, esi
	ror	edi, 8
	mov	eax, edi
	xor	eax, esi
	push	eax
	call	_XT
	pop	ecx
	mov	ecx, esi
	rol	esi, 8
	rol	ecx, 16					; 00000010H
	xor	eax, ecx
	xor	eax, esi
	xor	eax, edi
	mov	DWORD PTR _v$[esp+ebp*4+32], eax
	inc	ebp
	cmp	ebp, 4
	jb	SHORT $LL10@aes_enc

; 134  :                    ROTR32(w, 16) ^ 
; 135  :                    ROTL32(w,  8) ^ 
; 136  :                    XT(ROTR32(w, 8) ^ w);
; 137  :         }
; 138  :       }
; 139  : add_key:    
; 140  :       // add round key
; 141  :       for (i=0; i<4; i++) {

	mov	ebp, DWORD PTR _state$[esp+28]
	jmp	$add_key$35
$LN22@aes_enc:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 146  : }

	add	esp, 16					; 00000010H
	ret	0
_aes_enc ENDP
_TEXT	ENDS
END
