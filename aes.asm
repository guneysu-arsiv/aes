; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\hub\aes\aes.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_aes_enc
PUBLIC	_aes_setkey
PUBLIC	_aes_encrypt
PUBLIC	_gf_mul2
PUBLIC	_gf_mulinv
PUBLIC	_SubByte
PUBLIC	_SubWord
PUBLIC	_SubBytes
PUBLIC	_ShiftRows
PUBLIC	_MixColumn
PUBLIC	_MixColumns
PUBLIC	_AddRoundKey
PUBLIC	_XT
PUBLIC	_aesenc
; Function compile flags: /Ogspy
; File c:\hub\aes\aes.c
;	COMDAT _aesenc
_TEXT	SEGMENT
_v$ = -16						; size = 16
_state$ = 8						; size = 4
_key$ = 12						; size = 4
_last$ = 16						; size = 4
_aesenc	PROC						; COMDAT

; 261  : void aesenc (void *state, void *key, int last) {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp

; 262  :     w128_t  *s, *k, v;
; 263  :     uint32_t i, w, r;
; 264  :     
; 265  :     s=(w128_t*)state;
; 266  :     k=(w128_t*)key;
; 267  : 
; 268  :     // sub bytes and shift rows
; 269  :     for (i=0; i<16; i++) {     

	mov	ebp, DWORD PTR _state$[esp+20]
	xor	ebx, ebx
	push	edi
	mov	edi, ebx
	push	esi
$LL4@aesenc:

; 270  :       v.m[((i >> 2) + 4 - (i & 3) ) & 3][i & 3] = SubByte(s->b[i], AES_ENCRYPT);

	movzx	eax, BYTE PTR [edi+ebp]
	mov	esi, edi
	push	1
	push	eax
	and	esi, 3
	call	_SubByte
	pop	ecx
	pop	ecx
	mov	ecx, edi
	shr	ecx, 2
	sub	ecx, esi
	and	ecx, 3
	inc	edi
	lea	ecx, DWORD PTR [esi+ecx*4]
	mov	BYTE PTR _v$[esp+ecx+32], al
	cmp	edi, 16					; 00000010H
	jb	SHORT $LL4@aesenc

; 271  :     }
; 272  :   
; 273  :     // if not last round
; 274  :     if (!last) {

	cmp	DWORD PTR _last$[esp+28], ebx
	jne	SHORT $LN6@aesenc

; 275  :       // mix columns
; 276  :       for (i=0; i<4; i++) {

	mov	ebp, ebx
$LL7@aesenc:

; 277  :         w = v.w[i];

	mov	esi, DWORD PTR _v$[esp+ebp*4+32]

; 278  :         v.w[i] = ROTR32(w,  8) ^ 

	mov	edi, esi
	ror	edi, 8
	mov	eax, edi
	xor	eax, esi
	push	eax
	call	_XT
	pop	ecx
	mov	ecx, esi
	rol	esi, 8
	rol	ecx, 16					; 00000010H
	xor	eax, ecx
	xor	eax, esi
	xor	eax, edi
	mov	DWORD PTR _v$[esp+ebp*4+32], eax
	inc	ebp
	cmp	ebp, 4
	jb	SHORT $LL7@aesenc
	mov	ebp, DWORD PTR _state$[esp+28]
$LN6@aesenc:

; 279  :                  ROTR32(w, 16) ^ 
; 280  :                  ROTL32(w,  8) ^ 
; 281  :                  XT(ROTR32(w, 8) ^ w);
; 282  :       }
; 283  :     }
; 284  :     
; 285  :     // add round key
; 286  :     for (i=0; i<4; i++) {

	mov	edx, DWORD PTR _key$[esp+28]
	lea	eax, DWORD PTR _v$[esp+32]
	sub	edx, eax
	sub	ebp, eax
	pop	esi
$LL10@aesenc:
	lea	eax, DWORD PTR [edx+ebx*4]

; 287  :       s->w[i] = v.w[i] ^ k->w[i];

	mov	ecx, DWORD PTR _v$[esp+eax+28]
	lea	eax, DWORD PTR [ebx*4]
	xor	ecx, DWORD PTR _v$[esp+ebx*4+28]
	add	eax, ebp
	inc	ebx
	mov	DWORD PTR _v$[esp+eax+28], ecx
	cmp	ebx, 4
	jb	SHORT $LL10@aesenc
	pop	edi
	pop	ebp
	pop	ebx

; 288  :     }
; 289  : }

	add	esp, 16					; 00000010H
	ret	0
_aesenc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\aes\aes.c
;	COMDAT _XT
_TEXT	SEGMENT
_w$ = 8							; size = 4
_XT	PROC						; COMDAT

; 250  :     uint32_t t = w & 0x80808080;

	mov	ecx, DWORD PTR _w$[esp-4]
	and	ecx, -2139062144			; 80808080H

; 251  :     
; 252  :     return ( (w ^ t ) << 1) ^ ( ( t >> 7) * 0x0000001B);

	mov	eax, ecx
	shr	ecx, 7
	xor	eax, DWORD PTR _w$[esp-4]
	imul	ecx, ecx, 27
	add	eax, eax
	xor	eax, ecx

; 253  : }

	ret	0
_XT	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\aes\aes.c
;	COMDAT _AddRoundKey
_TEXT	SEGMENT
_state$ = 8						; size = 4
_w$ = 12						; size = 4
_rnd$ = 16						; size = 4
_AddRoundKey PROC					; COMDAT

; 177  :     uint32_t i;
; 178  :     uint8_t  *key=(uint8_t*)&w[rnd*4];

	mov	edx, DWORD PTR _rnd$[esp-4]
	mov	ecx, DWORD PTR _state$[esp-4]
	push	esi
	shl	edx, 4
	add	edx, DWORD PTR _w$[esp]
	push	16					; 00000010H

; 179  : 
; 180  :     for (i=0; i<16; i++) {

	sub	edx, ecx
	pop	esi
$LL8@AddRoundKe:

; 181  :       state->b[i] ^= key[i];

	mov	al, BYTE PTR [edx+ecx]
	xor	BYTE PTR [ecx], al
	inc	ecx
	sub	esi, 1
	jne	SHORT $LL8@AddRoundKe
	pop	esi

; 182  :     }
; 183  : }

	ret	0
_AddRoundKey ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\aes\aes.c
;	COMDAT _MixColumns
_TEXT	SEGMENT
_state$ = 8						; size = 4
_enc$ = 12						; size = 4
_MixColumns PROC					; COMDAT

; 158  : {

	push	ebx

; 159  :     uint32_t i, t, w;
; 160  : 
; 161  :     for (i=0; i<4; i++)

	mov	ebx, DWORD PTR _state$[esp]
	push	esi
	push	edi
	xor	esi, esi
$LL4@MixColumns:

; 162  :     {
; 163  :       w = state[i];
; 164  :       if (enc==AES_DECRYPT) {

	cmp	DWORD PTR _enc$[esp+8], 0
	mov	edi, DWORD PTR [ebx+esi*4]
	jne	SHORT $LN5@MixColumns

; 165  :         t = ROTR32(w, 16) ^ w;

	mov	eax, edi
	rol	eax, 16					; 00000010H
	xor	eax, edi

; 166  :         t = gf_mul2(gf_mul2(t));

	push	eax
	call	_gf_mul2
	push	eax
	call	_gf_mul2
	pop	ecx
	pop	ecx

; 167  :         w ^= t;

	xor	edi, eax
$LN5@MixColumns:

; 168  :       }
; 169  :       state[i] = MixColumn(w);

	push	edi
	call	_MixColumn
	mov	DWORD PTR [ebx+esi*4], eax
	inc	esi
	pop	ecx
	cmp	esi, 4
	jb	SHORT $LL4@MixColumns

; 170  :     }
; 171  : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
_MixColumns ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\aes\aes.c
;	COMDAT _MixColumn
_TEXT	SEGMENT
_w$ = 8							; size = 4
_MixColumn PROC						; COMDAT

; 150  : uint32_t MixColumn (uint32_t w) {

	push	esi

; 151  :     return ROTR32(w, 8) ^ 

	mov	esi, DWORD PTR _w$[esp]
	push	edi
	mov	edi, esi
	ror	edi, 8
	mov	eax, edi
	xor	eax, esi
	push	eax
	call	_gf_mul2
	pop	ecx
	mov	ecx, esi
	rol	esi, 8
	rol	ecx, 16					; 00000010H
	xor	eax, ecx
	xor	eax, esi
	xor	eax, edi
	pop	edi
	pop	esi

; 152  :            ROTR32(w, 16) ^ 
; 153  :            ROTR32(w, 24) ^ 
; 154  :            gf_mul2(ROTR32(w, 8) ^ w);
; 155  : }

	ret	0
_MixColumn ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\aes\aes.c
;	COMDAT _ShiftRows
_TEXT	SEGMENT
_state$ = 8						; size = 4
_enc$ = 12						; size = 4
_ShiftRows PROC						; COMDAT

; 122  : {

	push	ebx

; 123  :     uint32_t x, i, j;
; 124  : 
; 125  :     // shift 4 rows
; 126  :     for (i=0; i<4; i++) {

	mov	ebx, DWORD PTR _state$[esp]
	push	esi
	push	edi
	xor	esi, esi
	xor	edi, edi
$LL4@ShiftRows:

; 127  :       x=0;

	xor	edx, edx

; 128  :       // get row
; 129  :       for (j=i; j<16; j+=4) {

	mov	ecx, esi
	cmp	esi, 16					; 00000010H
	jae	SHORT $LN6@ShiftRows
$LL7@ShiftRows:

; 130  :         x |= state->b[j];

	movzx	eax, BYTE PTR [ecx+ebx]
	add	ecx, 4
	or	edx, eax

; 131  :         x=ROTR32(x, 8);

	ror	edx, 8
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LL7@ShiftRows
$LN6@ShiftRows:

; 132  :       }
; 133  :       // rotate depending on enc
; 134  :       if (enc==AES_ENCRYPT) {

	cmp	DWORD PTR _enc$[esp+8], 1
	jne	SHORT $LN11@ShiftRows

; 135  :         x = ROTR32(x, i*8);

	push	32					; 00000020H
	pop	ecx
	sub	ecx, edi

; 136  :       } else {

	jmp	SHORT $LN26@ShiftRows
$LN11@ShiftRows:

; 137  :         x = ROTL32(x, i*8);

	mov	ecx, edi
$LN26@ShiftRows:
	rol	edx, cl

; 138  :       }
; 139  :       // set row
; 140  :       for (j=i; j<16; j+=4) {

	mov	eax, esi
	cmp	esi, 16					; 00000010H
	jae	SHORT $LN2@ShiftRows
$LL10@ShiftRows:

; 141  :         state->b[j] = (x & 0xff);

	mov	BYTE PTR [eax+ebx], dl
	add	eax, 4

; 142  :         x >>= 8;

	shr	edx, 8
	cmp	eax, 16					; 00000010H
	jb	SHORT $LL10@ShiftRows
$LN2@ShiftRows:

; 123  :     uint32_t x, i, j;
; 124  : 
; 125  :     // shift 4 rows
; 126  :     for (i=0; i<4; i++) {

	add	edi, 8
	inc	esi
	cmp	edi, 32					; 00000020H
	jb	SHORT $LL4@ShiftRows

; 143  :       }
; 144  :     }
; 145  : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
_ShiftRows ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\aes\aes.c
;	COMDAT _SubBytes
_TEXT	SEGMENT
_state$ = 8						; size = 4
_enc$ = 12						; size = 4
_SubBytes PROC						; COMDAT

; 111  : {

	push	esi

; 112  :     int8_t i;
; 113  : 
; 114  :     for (i=0; i<16; i++) {

	mov	esi, DWORD PTR _state$[esp]
	push	edi
	push	16					; 00000010H
	pop	edi
$LL4@SubBytes:

; 115  :       state->b[i] = SubByte(state->b[i], enc);

	push	DWORD PTR _enc$[esp+4]
	movzx	eax, BYTE PTR [esi]
	push	eax
	call	_SubByte
	mov	BYTE PTR [esi], al
	inc	esi
	pop	ecx
	pop	ecx
	sub	edi, 1
	jne	SHORT $LL4@SubBytes

; 116  :     }
; 117  : }

	pop	edi
	pop	esi
	ret	0
_SubBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\aes\aes.c
;	COMDAT _SubWord
_TEXT	SEGMENT
_x$ = 8							; size = 4
_SubWord PROC						; COMDAT

; 96   : {

	push	ebx
	push	esi
	push	edi

; 97   :     uint8_t  i;
; 98   :     uint32_t r=0;

	mov	edi, DWORD PTR _x$[esp+8]
	xor	esi, esi
	push	4
	pop	ebx
$LL4@SubWord:

; 99   : 
; 100  :     for (i=0; i<4; i++) {
; 101  :       r |= SubByte(x & 0xFF, AES_ENCRYPT);

	push	1
	push	edi
	call	_SubByte
	movzx	eax, al
	or	esi, eax

; 102  :       r  = ROTR32(r, 8);
; 103  :       x >>= 8;

	shr	edi, 8
	pop	ecx
	ror	esi, 8
	pop	ecx
	sub	ebx, 1
	jne	SHORT $LL4@SubWord

; 104  :     }
; 105  :     return r;

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 106  : }

	ret	0
_SubWord ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\aes\aes.c
;	COMDAT _SubByte
_TEXT	SEGMENT
_x$ = 8							; size = 1
_enc$ = 12						; size = 4
_SubByte PROC						; COMDAT

; 68   :     uint8_t i, y=0, sb;
; 69   : 
; 70   :     if (enc==AES_ENCRYPT)

	cmp	DWORD PTR _enc$[esp-4], 1
	jne	SHORT $LN5@SubByte

; 71   :     {
; 72   :       sb = y = gf_mulinv (x);

	push	DWORD PTR _x$[esp-4]
	call	_gf_mulinv
	pop	ecx
	push	4
	mov	cl, al
	pop	edx
$LL4@SubByte:

; 73   : 
; 74   :       for (i=0; i<4; i++) {
; 75   :         y   = ROTL8(y, 1);

	rol	cl, 1

; 76   :         sb ^= y;

	xor	al, cl
	sub	edx, 1
	jne	SHORT $LL4@SubByte

; 77   :       }
; 78   :       sb ^= 0x63;

	xor	al, 99					; 00000063H

; 89   :     }
; 90   :     return sb;
; 91   : }

	ret	0
$LN5@SubByte:

; 79   :     } else {
; 80   :       // ------------------
; 81   :       y   = x ^ 0x63;

	mov	dl, BYTE PTR _x$[esp-4]
	xor	dl, 99					; 00000063H

; 82   :       y   = ROTL8(y, 1);

	rol	dl, 1

; 83   :       sb  = y;

	mov	al, dl

; 84   :       y   = ROTL8(y, 2);

	rol	dl, 2

; 85   :       sb ^= y;
; 86   :       y   = ROTL8(y, 3);

	mov	cl, dl
	rol	cl, 3

; 87   :       sb ^= y;

	xor	cl, al
	xor	cl, dl

; 88   :       sb  = gf_mulinv(sb);

	movzx	eax, cl
	push	eax
	call	_gf_mulinv
	pop	ecx

; 89   :     }
; 90   :     return sb;
; 91   : }

	ret	0
_SubByte ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\aes\aes.c
;	COMDAT _gf_mulinv
_TEXT	SEGMENT
tv164 = 8						; size = 4
_x$ = 8							; size = 1
_gf_mulinv PROC						; COMDAT

; 45   : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 46   :     uint8_t y=x, i;

	mov	bl, BYTE PTR _x$[ebp]

; 47   : 
; 48   :     if (x)

	test	bl, bl
	je	SHORT $LN6@gf_mulinv

; 49   :     {
; 50   :       // calculate logarithm gen 3
; 51   :       for (y=1, i=0; ;i++) {
; 52   :         y ^= gf_mul2 (y);

	push	1
	xor	bh, bh
	call	_gf_mul2
	pop	ecx
	mov	ecx, eax
	xor	cl, 1
	jmp	SHORT $LN20@gf_mulinv
$LL4@gf_mulinv:
	movzx	eax, cl
	inc	bh
	push	eax
	call	_gf_mul2
	pop	ecx
	mov	ecx, DWORD PTR tv164[ebp]
	xor	cl, al
$LN20@gf_mulinv:
	mov	DWORD PTR tv164[ebp], ecx

; 53   :         if (y==x) break;

	cmp	cl, bl
	jne	SHORT $LL4@gf_mulinv

; 54   :       }
; 55   :       i = ~i;

	not	bh

; 56   :       // calculate anti-logarithm gen 3
; 57   :       for (y=1; i; i++) {

	mov	bl, 1
	test	bh, bh
	je	SHORT $LN6@gf_mulinv

; 54   :       }
; 55   :       i = ~i;

	neg	bh
	push	esi
	movzx	esi, bh
$LL7@gf_mulinv:

; 58   :         y ^= gf_mul2(y);

	movzx	ecx, bl
	push	ecx
	call	_gf_mul2
	xor	bl, al
	pop	ecx
	sub	esi, 1
	jne	SHORT $LL7@gf_mulinv
	pop	esi
$LN6@gf_mulinv:

; 59   :       }
; 60   :     }
; 61   :     return y;

	mov	al, bl
	pop	ebx

; 62   : }

	pop	ebp
	ret	0
_gf_mulinv ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\aes\aes.c
;	COMDAT _gf_mul2
_TEXT	SEGMENT
_w$ = 8							; size = 4
_gf_mul2 PROC						; COMDAT

; 36   :     uint32_t t = w & 0x80808080;

	mov	ecx, DWORD PTR _w$[esp-4]
	and	ecx, -2139062144			; 80808080H

; 37   :     
; 38   :     return ( (w ^ t ) << 1) ^ ( ( t >> 7) * 0x0000001B);

	mov	eax, ecx
	shr	ecx, 7
	xor	eax, DWORD PTR _w$[esp-4]
	imul	ecx, ecx, 27
	add	eax, eax
	xor	eax, ecx

; 39   : }

	ret	0
_gf_mul2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\aes\aes.c
;	COMDAT _aes_encrypt
_TEXT	SEGMENT
tv210 = 8						; size = 4
_ctx$ = 8						; size = 4
_state$ = 12						; size = 4
tv203 = 16						; size = 4
_enc$ = 16						; size = 4
_aes_encrypt PROC					; COMDAT

; 215  : {

	push	ebx
	push	ebp

; 216  :     uint8_t  round;
; 217  :     uint32_t *w=(uint32_t*)ctx->w;
; 218  : 
; 219  :     if (enc==AES_ENCRYPT)
; 220  :     {
; 221  :       AddRoundKey (state, w, 0);

	mov	ebp, DWORD PTR _ctx$[esp+4]
	push	esi
	mov	esi, DWORD PTR _state$[esp+8]
	push	edi
	mov	edi, DWORD PTR _enc$[esp+12]
	cmp	edi, 1
	jne	SHORT $LN8@aes_encryp
	push	0
	push	ebp
	push	esi
	call	_AddRoundKey
	add	esp, 12					; 0000000cH

; 222  : 
; 223  :       for (round=1; round<Nr; round++)

	push	14					; 0000000eH
	pop	ebx
	push	13					; 0000000dH
	mov	DWORD PTR tv210[esp+16], ebx
	pop	ebx
$LL4@aes_encryp:

; 224  :       {
; 225  :         SubBytes (state, enc);

	push	1
	push	esi
	call	_SubBytes

; 226  :         ShiftRows (state, enc);

	push	1
	push	esi
	call	_ShiftRows

; 227  :         MixColumns (state, enc);

	push	1
	push	esi
	call	_MixColumns

; 228  :         AddRoundKey (state, w, round);

	push	edi
	push	ebp
	push	esi
	call	_AddRoundKey
	add	esp, 36					; 00000024H
	inc	edi
	sub	ebx, 1
	jne	SHORT $LL4@aes_encryp

; 229  :       }
; 230  :     }

	mov	edi, DWORD PTR _enc$[esp+12]
	mov	ebx, DWORD PTR tv210[esp+12]
	jmp	SHORT $LN6@aes_encryp
$LN8@aes_encryp:

; 231  :     else
; 232  :     {
; 233  :       AddRoundKey (state, w, Nr);

	push	14					; 0000000eH
	push	ebp
	push	esi
	call	_AddRoundKey
	add	esp, 12					; 0000000cH

; 234  : 
; 235  :       for (round=Nr-1; round>0; round--)

	push	13					; 0000000dH
	pop	ebx
	mov	DWORD PTR tv203[esp+12], ebx
$LL7@aes_encryp:

; 236  :       {
; 237  :         SubBytes (state, enc);

	push	edi
	push	esi
	call	_SubBytes

; 238  :         ShiftRows (state, enc);

	push	edi
	push	esi
	call	_ShiftRows

; 239  :         AddRoundKey (state, w, round);

	push	DWORD PTR tv203[esp+28]
	push	ebp
	push	esi
	call	_AddRoundKey

; 240  :         MixColumns (state, enc);

	push	edi
	push	esi
	call	_MixColumns
	add	esp, 36					; 00000024H
	dec	DWORD PTR tv203[esp+12]
	sub	bl, 1
	jne	SHORT $LL7@aes_encryp
$LN6@aes_encryp:

; 241  :       }
; 242  :     }
; 243  :     
; 244  :     SubBytes (state, enc);

	push	edi
	push	esi
	call	_SubBytes

; 245  :     ShiftRows (state, enc);

	push	edi
	push	esi
	call	_ShiftRows

; 246  :     AddRoundKey (state, w, round);

	movzx	eax, bl
	push	eax
	push	ebp
	push	esi
	call	_AddRoundKey
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 247  : }

	ret	0
_aes_encrypt ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\aes\aes.c
;	COMDAT _aes_setkey
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_key$ = 12						; size = 4
_aes_setkey PROC					; COMDAT

; 189  :     int      i;
; 190  :     uint32_t x;
; 191  :     uint32_t *w=(uint32_t*)ctx->w;
; 192  :     uint32_t rcon=1;
; 193  : 
; 194  :     for (i=0; i<Nk; i++) {

	mov	edx, DWORD PTR _key$[esp-4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _ctx$[esp+8]
	xor	ebp, ebp
	push	edi
	push	8
	pop	ebx
	inc	ebp
	mov	ecx, esi
	sub	edx, esi
	mov	edi, ebx
$LL4@aes_setkey:

; 195  :       w[i]=((uint32_t*)key)[i];

	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR [ecx], eax
	lea	ecx, DWORD PTR [ecx+4]
	sub	edi, 1
	jne	SHORT $LL4@aes_setkey
$LL7@aes_setkey:

; 196  :     }
; 197  : 
; 198  :     for (i=Nk; i<Nb*(Nr+1); i++)
; 199  :     {
; 200  :       x = w[i-1];

	mov	edi, DWORD PTR [esi+28]

; 201  :       if ((i % Nk)==0) {

	mov	eax, ebx
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN21@aes_setkey
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN21@aes_setkey:
	jne	SHORT $LN8@aes_setkey

; 202  :         x = RotWord(x);

	ror	edi, 8

; 203  :         x = SubWord(x) ^ rcon;

	push	edi
	call	_SubWord
	mov	edi, eax

; 204  :         rcon=gf_mul2(rcon);

	push	ebp
	xor	edi, ebp
	call	_gf_mul2
	pop	ecx
	mov	ebp, eax
	jmp	SHORT $LN22@aes_setkey
$LN8@aes_setkey:

; 205  :       } else if ((Nk > 6) && ((i % Nk) == 4)) {

	cmp	eax, 4
	jne	SHORT $LN10@aes_setkey

; 206  :         x=SubWord(x);

	push	edi
	call	_SubWord
	mov	edi, eax
$LN22@aes_setkey:
	pop	ecx
$LN10@aes_setkey:

; 207  :       }
; 208  :       w[i] = w[i-Nk] ^ x;

	mov	ecx, DWORD PTR [esi]
	xor	ecx, edi
	inc	ebx
	mov	DWORD PTR [esi+32], ecx
	add	esi, 4
	cmp	ebx, 60					; 0000003cH
	jl	SHORT $LL7@aes_setkey

; 209  :     }
; 210  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
_aes_setkey ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\aes\aes.c
;	COMDAT _aes_enc
_TEXT	SEGMENT
_state$ = 8						; size = 4
_key$ = 12						; size = 4
_aes_enc PROC						; COMDAT

; 292  :     int     i, r;
; 293  :     w128_t  *s, *k;
; 294  :     
; 295  :     s=(w128_t*)state;
; 296  :     k=(w128_t*)key;
; 297  :     
; 298  :     for (i=0; i<4; i++) {

	mov	ecx, DWORD PTR _state$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _key$[esp+4]
	mov	edx, edi
	push	4
	sub	edx, ecx
	pop	esi
$LL4@aes_enc:

; 299  :       s->w[i] ^= k->w[i];

	mov	eax, DWORD PTR [edx+ecx]
	xor	DWORD PTR [ecx], eax
	lea	ecx, DWORD PTR [ecx+4]
	sub	esi, 1
	jne	SHORT $LL4@aes_enc

; 300  :     }
; 301  :     k++;

	add	edi, 16					; 00000010H

; 302  :     for (r=1; r<=Nr; r++, k++) {

	inc	esi
$LL7@aes_enc:

; 303  :       aesenc(s, k, r==Nr);

	xor	eax, eax
	cmp	esi, 14					; 0000000eH
	sete	al
	push	eax
	push	edi
	push	DWORD PTR _state$[esp+12]
	call	_aesenc
	add	esp, 12					; 0000000cH
	add	edi, 16					; 00000010H
	inc	esi
	cmp	esi, 14					; 0000000eH
	jle	SHORT $LL7@aes_enc

; 304  :     }      
; 305  : }

	pop	edi
	pop	esi
	ret	0
_aes_enc ENDP
_TEXT	ENDS
END
